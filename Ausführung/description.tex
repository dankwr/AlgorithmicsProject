\documentclass[a4paper, 12pt]{article}

\usepackage{amsmath, graphicx, url}
\usepackage{amsfonts}
\usepackage[T1]{fontenc}
\usepackage{comment}
\usepackage{tabto}
\usepackage{hyperref}
\usepackage{booktabs} 
\usepackage[ngerman]{babel}
\usepackage{pgfplots}


\title{Projekt: Die Nordischen Filmtage}
\author{
    Raik Dankworth}
\date{}

\begin{document}

\maketitle

\section{Einleitung}

In diesem Projekt geht es darum, sich ein Verfahren zu überlegen, mit dessen Hilfe man entscheiden kann, welche Filme man bei den Nordischen Filmtage besuchen sollte.
Die Anforderungen sind dabei, dass keine Filme doppelt besucht werden und man nur ein Film gleichzeitig ansehen kann.
Es ist der Plan zu wählen, mit dessen Hilfe man so viele gute Filme wie möglich sehen kann.
Um die Filme zu vergleichen, wird das ImDb-Ranking genutzt.
Dafür sind zu allen Filmvorstellungen angegeben, an welchen Tag und zu welcher Zeit welcher Film, identifiziert mit seinem Titel, gezeigt werden. 
Zusätzlich ist noch die Dauer der Vorstellung und das ImDb-Ranking des Films angegeben.
Die Laufzeit zwischen den Spielstätten spielt keine Rolle, d.h. am Ende einer Vorstellung kann direkt die nächste Vorstellung besucht werden.

\section{Vorgehen}

\subsection{Definition des ILP}
Das Schedule-Problem wird als 0-1-ILP modelliert.

\tabto{.03\linewidth} maximiere 
\begin{equation} \label{equ:objectFunction1}
    \sum_i^n r_i x_i
\end{equation}
\tabto{.03\linewidth} sodass 
\begin{equation} \label{equ:titleConstraints1}
    \forall f: \sum\limits_{i < n \> \land \> f = f_i} x_i \leq 1
\end{equation}
\begin{equation} \label{equ:overlappingConstraints1}
    \forall i < j < n \textmd{ mit  } t_i \cap t_j \neq \emptyset: x_i + x_j \leq 1
\end{equation}
\begin{equation} \label{equ:ilp1}
    \forall i < n: x_i \in \{0, 1\}
\end{equation}
Alle $n$ Filmvorstellungen werden durchnummeriert und mit den Variablen $x_i$ abgebildet.
Ist der Wert dieser Variablen 1, sollte diese Vorstellung besucht werden, sonst ist nur 0 zulässig \eqref{equ:ilp1}.
Es muss dabei jedoch auch beachtet werden, dass jeder Film $f$ nur maximal einmal besucht werden darf.
Mehrere Filmvorstellung eines Films sind somit nicht zulässig \eqref{equ:titleConstraints1}.
Auch dürfen sich die Vorstellungszeiten $t_i$ der besuchten Vorstellungen nicht überschneiden \eqref{equ:overlappingConstraints1}.
Wir interessieren uns natürlich nur für die besten Filme, welche vorgestellt werden.
Dies wird über die Zielfunktion \eqref{equ:objectFunction1} mittels des Ranking $r_i$ der jeweiligen Vorstellungen $x_i$ abgebildet.

\subsection{Programmierung}

Das Programm ist in Java programmiert und im GitHub \footnote{\url{https://github.com/dankwr/AlgorithmicsProject}} hinterlegt.
Hierbei sind zwei unterschiedliche Einstiegsmöglichkeiten gewählt worden. 
Zum einem kann eine spezifische CSV-Datei eingelesen werden und der enthaltene Vorstellungsplan wird ausgewertet.
Am Ende wird auf der Console ausgegeben, welche Vorstellungen besucht werden sollten. 
Dies wird über \texttt{ScheduleCinemaShowingLpSolver} gemacht.
Zum anderen steht ein Programm zu Verfügung mit dessen Hilfe alle CSV-Dateien in einem Ordner verarbeitet werden.
Hierbei wird jedoch nur die Ausführungszeit und das Ergebnis der Berechnung ausgegeben.
Die Ausführungszeit ist auf 5 min begrenzt.
Dies wird von  \texttt{ScheduleAllCinemaShowingLpSolver} ausgeführt.

Der Programm zum Berechnen der optimalen Lösung ist in 3 Teilaufgaben unterteilt. 
Als erstes wird eine bestimmte CSV-Datei eingelesen und daraus ein codeseitige Abbildung der Filmvorstellungen erstellt.
Danach werden mit diesen Filmvorstellungen das lineare Programm mit seinen Einschränkungen erzeugt.
Mit diesen linearen Programm kann dann die optimalste Lösung für den Vorstellungsplan aus der gegebenen CSV-Datei bestimmt werden.

\subsubsection{CSV-Datei einlesen und aufbereiten}

Die einzelnen Filmvorstellungen sind im Code als Objekte der Klasse \linebreak \texttt{CinemaShowing} abgebildet.
Diese werde in der Klasse  \linebreak \texttt{MapCsvToCinemaShowing} aus den CSV-Dateien erzeugt.
Wichtig zu erwähnen ist hierbei, dass schon eine gewisse Aufbereitung der Informationen vorgenommen wird.
So wird die Uhrzeit als Integer festgehalten, indem die genaue Minute des Tages berechnet wird. 
Anders gesagt die Stunde der Uhrzeit wurde mit 60 multipliziert und mit der Minute der Uhrzeit addiert und als Startzeit gemerkt.
Die Dauer der Vorstellung wird auch nicht so weiter verwendet, sondern mit der Startzeit addiert, um die entsprechende Endzeit der Vorstellung zu erhalten.
Diese Vorberechnung hat den Hintergrund, das hiermit eine einfachere Abfrage zur Überschneidung zweier Vorstellungen möglich ist.
Alle anderen Informationen werden genauso wie in der CSV-Datei angegeben festgehalten.

\subsubsection{Lineares Programm erstellen}

Im ersten Ansatz hatte ich einen eigenen Simplex Algorithmus entwickelt.
Jedoch hat besonders die Pivot-Berechnung eine Fehleranalyse extrem schwer gemacht, weshalb ich zum Teil nicht mehr wusste, ob das lineare Programm schlecht gewählt war oder der Simplex Algorithmus fehlerhaft.
Deshalb habe ich nach kurzer Zeit stattdessen die Bibliothek \texttt{LpSolve} in der Version 5.5.2 genutzt.

Bei beiden Varianten müssen jedoch aus den Filmvorstellungen die Variablen und die Einschränkungen generiert werden.
Die Variablen sind über \texttt{LinearProgramVariable} abgebildet, wobei dort nur die \texttt{CinemaShowing} mit einem Index verbunden werden.
Diese werden dann auch benutzt, um die beiden Einschränkungsarten \eqref{equ:titleConstraints1} und \eqref{equ:overlappingConstraints1} zu erstellen.
Die Objekte der Klasse \texttt{TitleConstraint} bilden dabei die Einschränkungen der Art \eqref{equ:titleConstraints1} ab und \texttt{OverlappingConstraint} die Art \eqref{equ:overlappingConstraints1}.
Hierbei wird beachtet, dass doppelte oder sinnlose Einschränkungen vermieden werden.
Das heißt Filme, die nur einmal vorkommen, brauchen auch nicht über die \texttt{TitleConstraint} abgebildet werden, da hier nicht verhindert werden muss, dass dieser Film mehr als einmal besucht wird.
Genauso wird beim \texttt{OverlappingConstraint} darauf geachtet, dass jede Einschränkung nur einmal auftaucht.

Wichtig ist hierbei noch, dass ein 0-1-ILP abgebildet werden muss.
Dies geht über die Bibliothek \texttt{LpSolve} relativ charmant, da hierfür zu jeder Variable nur ein Flag und die Oberschranke auf 1 gesetzt werden muss.
Bei dem eigenen Simplex Algorithmus hatte ich zu erst mit einer Relaxierung versucht, in der Hoffnung das ich später mit besseren Einschränkungen das Verfahren nutzen kann.
Damals war mir schon bewusst, dass die Relaxierung wahrscheinlich nicht funktioniert, da die Koeffizientenmatrix wahrscheinlich nicht total unimodular ist.  

Im \texttt{MapCinemaShowingsToLinearProgram} werden diese Variablen und Einschränkungen erzeugt und dann etwa mit der Methode \linebreak \texttt{convertLinearProgram} zu einem linearen Programm umgewandelt, welcher mein eigener Simplex Algorithmus verarbeiten kann oder mit Hilfe der Methode \texttt{convertLpSolve} in einen \texttt{LpSolve}.
Bei beiden Formaten wird dies noch in \texttt{Wrapper} verpackt, da beide die Informationen, welche Indizes welche Filmvorstellungen abbilden, nicht enthalten.

\subsubsection{Optimale Lösung bestimmen}

Die Ermittlung der optimalen Lösung zu dem LP ist mittels des \texttt{LpSolve} einfach.
Dort muss auf dem entsprechende erzeugten \texttt{LpSolve} nur noch die Methode \texttt{solve} aufgerufen werden.
Nach der Terminierung oder dem Timeout kann, das Ergebnis ausgewertet werden.

Auf den eigenen Simplex Algorithmus möchte ich hier nicht zu sehr eingehen, da nach dem Nutzen der externen Bibliothek dieser nicht weiter gepflegt bzw. verwendet wurde.
Jedoch möchte ich erwähnen, dass dies noch weiterhin im Package \texttt{SimplexAlgorithm} vorliegt.

\section{Auswertung}


\begin{table}
    \begin{tabular}{r|l|r|c|r}
        \toprule
        Nummer & Datei & Ausführungszeit in sec & Lösungsstatus & Güte \\
        \midrule
        1 & NFL18\_039\_So & & & \\
        2 & NFL18\_047\_Do & & & \\
        3 & NFL19\_033\_Premiere & & & \\
        4 & NFL19\_035\_startSE & & & \\
        5 & NFL17\_036\_SE & & & \\
        6 & NFL17\_041\_Do & & & \\
        7 & NFL17\_042 & & & \\
        8 & NFL17\_042\_So & & & \\
        9 & NFL17\_043\_Fr & & & \\
        10 & NFL17\_051\_gute\_IMDb\_Spielfilme & & & \\
        11 & NFL17\_051\_Sa & & & \\
        12 & NFL17\_064\_WE\_CS & & & \\
        \bottomrule
    \end{tabular}
    \caption{Ergebnisse für die reelen Daten} 
    \label{tab:results} 
\end{table}

\begin{figure}
    \begin{tikzpicture}
        \begin{axis}[
        ybar,
        bar width=10pt,
        %
        nodes near coords,
        nodes near coords align=above,
        point meta=rawy,
        %
        axis x line=bottom,
        axis y line=left,
        ymajorgrids=true,
        %
        ylabel=Ausführungszeit in sec,
        ymin=0,
        ytick={0,60,120,180,240,300,360},
        enlargelimits=auto,
        %
        xlabel=Dateien-Nummer,
        symbolic x coords ={1,2,3,4,5,6,7,8,9,10,11,12},
        ]
    
        \addplot[fill=blue] coordinates {
            (1,220.6)
            (2,219.26)
            (3,197.67)
            (4,167.9)
            (5,40)
            (6,1)
            (7,1)
            (8,1)
            (9,1)
            (10,1)
            (11,1)
            (12,1)
        };
        \end{axis} 
    \end{tikzpicture}
    \caption{Vergleich der Ausführungszeiten zu den reelen Datensätzen}
    \label{fig:executiontime}
\end{figure}


\end{document}
